#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     IROne,          sensorNone)
#pragma config(Sensor, S2,     IRTwo,          sensorI2CCustom)
#pragma config(Sensor, S3,     Motor,          sensorI2CCustom)
#pragma config(Sensor, S4,     IROne,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,      ,             tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,      ,             tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Full Program.c"


void forward(int rotations)
{
	nMotorEncoder[motorD] = 0;          // reset the Motor Encoder of Motor B
	while(nMotorEncoder[motorD] < (rotations * 360))  // while the Motor Encoder of Motor B has not yet reached 360 counts:
	{
  	motor[motorD] = 100;                 // motor B is given a power level of 75
  	motor[motorE] = 100;                 // motor C is given a power level of 75
	}
	motor[motorD] = 0;                  // motor B is given a power level of 0 (stop)
	motor[motorE] = 0;                  // motor C is given a power level of 0 (stop)
}
void backward(int rotations)
{
	nMotorEncoder[motorD] = 0;          // reset the Motor Encoder of Motor B
	while(nMotorEncoder[motorD] < (rotations * -360))  // while the Motor Encoder of Motor B has not yet reached 360 counts:
	{
  	motor[motorD] = -100;                 // motor B is given a power level of 75
  	motor[motorE] = -100;                 // motor C is given a power level of 75
	}
	motor[motorD] = 0;                  // motor B is given a power level of 0 (stop)
	motor[motorE] = 0;                  // motor C is given a power level of 0 (stop)
}
void turnD(int rotations)
{
	nMotorEncoder[motorD] = 0;          // reset the Motor Encoder of Motor B
	while(nMotorEncoder[motorD] < (rotations * -360))  // while the Motor Encoder of Motor B has not yet reached 360 counts:
	{
  	motor[motorD] = -100;                 // motor B is given a power level of 75
  	motor[motorE] = 100;                 // motor C is given a power level of 75
	}
	motor[motorD] = 0;                  // motor B is given a power level of 0 (stop)
	motor[motorE] = 0;                  // motor C is given a power level of 0 (stop)
}
void turnE(int rotations)
{
	nMotorEncoder[motorD] = 0;          // reset the Motor Encoder of Motor B
	while(nMotorEncoder[motorD] < (rotations * 360))  // while the Motor Encoder of Motor B has not yet reached 360 counts:
	{
  	motor[motorD] = 100;                 // motor B is given a power level of 75
  	motor[motorE] = -100;                 // motor C is given a power level of 75
	}
	motor[motorD] = 0;                  // motor B is given a power level of 0 (stop)
	motor[motorE] = 0;                  // motor C is given a power level of 0 (stop)
}


task main()
{
	int Configuration = CheckPosition();
	if(Configuration == 1)
	{
		forward(20);
	}else if(Configuration == 2)
	{
		turnE(2);
		forward(4);
		turnD(2);
		forward(16);
	}else if(Configuration == 3)
	{
		turnE(4);
		forward(20);
		turnD(4);
		forward(10);
	}
	/*
	//globals
	int Configuration = -1;

	//check the configuration
	Configuration = CheckPosition();

	//get up to the line position
	MoveStraight();
	sleep(1500);
	Stop();

	if(Configuration == 3)
	{

	}
	if(Configuration == 2)
	{

	}
	if(Configuration == 1)
	{
		MoveForwardDistance(3);
		Stop();
	}

	//stop the robot
	Stop();
	*/
}
