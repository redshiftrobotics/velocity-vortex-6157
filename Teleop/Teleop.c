//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Tankdrive.c

/*

(C) Copyright 2014 Samin Zach and Matthew Kelsey

This file is part of the FTC team 6157 application code.

FTC team 6157 application code is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software
Foundation, either version 2 of the License, or (at your
option) any later version.

FTC team 6157 application code is distributed in the hope that
it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with FTC team 6157 application code. If not, see
<http://www.gnu.org/licenses/>.

*/
#pragma config(Sensor, S1, , sensorI2CCustom)
#pragma config(Motor,  motorA,          spinner1,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          spinner2,      tmotorNXT, PIDControl, encoder)

#include "../Libraries/Motors.h"
#include "../Libraries/Servos.h"

#include "JoystickDriver.c"

//----------------------------------------------------------------checkback (constrain)

int constrain(int x, int min, int max)
{
	if (x > max)
		return max;
	if (x < min)
		return min;
	return x;
}

int joymotor (int joy)
{
	int motor;
	if(joy > 7 || joy < -7)
	{
		motor = joy * 100 / 127; //-----------------------------------checkback (the equation? check math)
	}
	else
	{
		return 0;
	}
	return constrain(motor,-100,100);
}


//toggle
bool toggle(int joybtn, bool toggleSwitch)
{
	bool btnup = true;

		if(joy1Btn(joybtn) == 1 && btnup == true)
			{
				//transition down
				toggleSwitch =! toggleSwitch;
				btnup = false;
				Sleep(150);
			}
			else if(joy1Btn(joybtn) == 0 && btnup == false)
			{
				//transition up
				btnup = true;
			}

			return toggleSwitch;



}

int servo2angle = 1;

void dumperForward()
{
	//wait1Msec(10);
	servo2angle = 200;
	Servos_SetPosition(S1, 2, 2, servo2angle);
	//wait1Msec(1000);
	//servo2angle = 126;
	//Servos_SetPosition(S1, 2, 2, servo2angle);
}

void dumperBackward()
{
	wait10Msec(10);
	servo2angle = 50;
	Servos_SetPosition(S1, 2, 2, servo2angle);
	wait10Msec(1);
	servo2angle = 126;
	Servos_SetPosition(S1, 2, 2, servo2angle);
}



task main()
{
	int SpeedLeft = 0;
	int SpeedRight = 0;
	int SpeedArm = 0;
	int servoangle = 0;
	bool btnup = true;
	bool grabberToggle = true;
	bool sweeperToggle = true;
	bool dumperToggle = true;
	while(true)
	{


//driving

		getJoystickSettings(joystick);

		SpeedRight = joymotor(-joystick.joy1_y2);
		SpeedLeft = joymotor(joystick.joy1_y1);
//sweeper

		//sweeperToggle = toggle(7+1, sweeperToggle);
		if(joy2Btn(7+1) == 1)
		{
			motor[motorA] = 100;
			motor[motorB] = 100;
		}
		else if(joy2Btn(6+1) == 1)
		{
			motor[motorA] = -100;
			motor[motorB] = -100;
		}
		else
		{
			motor[motorA] = 0;
			motor[motorB] = 0;
		}
//tubegrabber

		grabberToggle = toggle(1+1, grabberToggle);
		servoangle = grabberToggle ? 95 : 207;


//arm
		if(joy2Btn(6+1) == 1)
		{
			SpeedArm = joymotor(joystick.joy2_y1/2);

		}
		else
		{
			SpeedArm = joymotor(joystick.joy2_y1);
		}

//DUMPER

		if(joy2Btn(1) == 1)
		{
			servo2angle = 1;
		}
		else if(joy2Btn(2) == 1)
		{
			servo2angle = 70;
		}
		else if(joy2Btn(3) == 1)
		{
			servo2angle = 120;
		}
		else{}


		/* OLD DUMPPER
		if(joy2Btn(1) == 1)
		{
			servo2angle = 200;
		}
		else if(joy2Btn(2) == 1)
		{
			servo2angle = 50;
		}
		else
		{
			servo2angle = 126;
		}
		*/

//removed threshold already implemented in joymotor()

	Servos_SetPosition(S1, 2, 1, servoangle);
	Servos_SetPosition(S1, 2, 2, servo2angle);
	Motors_SetSpeed(S1, 1, 1, -SpeedLeft);
	Motors_SetSpeed(S1, 3, 1, SpeedArm);
	Motors_SetSpeed(S1, 1, 2, -SpeedRight);



	}

}
