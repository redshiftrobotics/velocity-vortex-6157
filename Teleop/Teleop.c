#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Sensor, S1, , sensorI2CCustom)
#pragma config(Motor,  motorA,          spinner1,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          spinner2,      tmotorNXT, PIDControl, encoder)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Tankdrive.c

/*

(C) Copyright 014 Samin Zach and Matthew Kelsey

This file is part 1of the FTC team 6157 application code.

FTC team 6157 application code is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software
Foundation, either version 2 of the License, or (at your
option) any later version.

FTC team 6157 application code is distributed in the hope that
it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public
License along with FTC team 6157 application code. If not, see
<http://www.gnu.org/licenses/>.
*/

#include "../Libraries/Motors.h"
#include "../Libraries/Servos.h"

#include "JoystickDriver.c"

/////////////////////////////////////////////////////////////////////////
/// BUG NOTES -- Everything you need to know about our programs bugs. ///
/////////////////////////////////////////////////////////////////////////
/*

Many interesting developments were made in the way of discovering the cause of the "infinity bug."

Unfortunately the infinity bug was not reproducable after a good 45 minutes of solid robot driving with thourough movement
and vigourous routines.

First was that the constrain and joymotor functions were not infact written by 2856 and therefore are falible. (Not that
2856 is infallible but deffinitely less so than our team). I did however read through the functions and they appear to be
completely functional. I also tried removing the constrain function (after consulting AJ to be sure it wouldn't burn out
the motors). There was apparent difference, the small delay between controller input and robot action remained. I left the
constrain function in as it was causing no problems and is a good safety measure to prevent against motor strain. Joymotor
also has a weird equation that is noted below. It appears to be attempting to act somewhat like a constrain function as well
when removed, a joystick value of 128 or -128 (only works on some joysticks) will cause the motor(s) being controlled by that
joystick to stop moving entirely until you move the joystick back to a value under 128 or above -128.

I don't think either of these complications are related to the infinity bug directly but they could be caused by the same
thing as the infinity bug.

In retrospect no real progress was made today.



*/

int constrain(int x, int min, int max)
{
	if (x > max)
		return max;
	if (x < min)
		return min;
	return x;
}

int joymotor (int joy)
{
	int motor;
	if(joy > 20 || joy < -20)
	{
		motor = joy * 100 / 127;
	}
	else
	{
		return 0;
	}

	return constrain(motor,-100,100);

}


//toggle
bool toggle(int joybtn, bool toggleSwitch)
{
	bool btnup = true;

		if(joy1Btn(joybtn) == 1 && btnup == true)
			{
				//transition down
				toggleSwitch =! toggleSwitch;
				btnup = false;
				Sleep(150);
			}
			else if(joy1Btn(joybtn) == 0 && btnup == false)
			{
				//transition up
				btnup = true;
			}

			return toggleSwitch;
}

int servo2angle = 1;

void dumperForward()
{
	//wait1Msec(10);
	servo2angle = 200;
	Servos_SetPosition(S1, 2, 2, servo2angle);
	//wait1Msec(1000);
	//servo2angle = 126;
	//Servos_SetPosition(S1, 2, 2, servo2angle);
}

void dumperBackward()
{
	wait10Msec(10);
	servo2angle = 50;
	Servos_SetPosition(S1, 2, 2, servo2angle);
	wait10Msec(1);
	servo2angle = 126;
	Servos_SetPosition(S1, 2, 2, servo2angle);
}



task main()
{
	int startTele = Motors_GetPosition(S1, 3, 1);
	int SpeedLeft = 0;
	int SpeedRight = 0;
	int SpeedArm = 0;
	int servoangle = 0;
	bool btnup = true;
	bool grabberToggle = true;
	bool sweeperToggle = true;
	bool dumperToggle = true;
	while(true)
	{



	//driving

	getJoystickSettings(joystick);

	SpeedRight = joymotor(joystick.joy1_y2);
	SpeedLeft = joymotor(joystick.joy1_y1);





//sweeper

		//sweeperToggle = toggle(7+1, sweeperToggle);
		if(joy2Btn(7+1) == 1)
		{
			motor[motorA] = 100;
			motor[motorB] = 100;
		}
		else if(joy2Btn(6+1) == 1)
		{
			motor[motorA] = -100;
			motor[motorB] = -100;
		}
		else
		{
			motor[motorA] = 0;
			motor[motorB] = 0;
		}
//tubegrabber

		grabberToggle = toggle(1+1, grabberToggle);
		servoangle = grabberToggle ? 95 : 207;


//arm
		if(joy2Btn(6+1) == 1)
		{
			SpeedArm = joymotor(joystick.joy2_y1/2);

		}
		else
		{
			SpeedArm = joymotor(joystick.joy2_y1);
		}

//DUMPER

		if(joy2Btn(1) == 1)
		{
			servo2angle = 60;
		}
		else if(joy2Btn(2) == 1)
		{
			servo2angle = 125;
		}
		else if(joy2Btn(3) == 1)
		{
			servo2angle = 185;
		}
		else{}

//ARM
		if(joystick.joy2_TopHat == 0) //CENTER
		{
			while(Motors_GetPosition(S1, 3, 1) - startTele < 17000)
			{
				Motors_SetSpeed(S1, 3, 1, 100);
			}
		}
		else if(joystick.joy2_TopHat == 6) //LARGE
		{
			while(Motors_GetPosition(S1, 3, 1) - startTele < 11100)
			{
				Motors_SetSpeed(S1, 3, 1, 100);
			}
		}
		else if(joystick.joy2_TopHat == 4) //LARGE
		{
			while(Motors_GetPosition(S1, 3, 1) - startTele < 5500)
			{
				Motors_SetSpeed(S1, 3, 1, 100);
			}
		}



		/* OLD DUMPPER
		if(joy2Btn(1) == 1)
		{
			servo2angle = 200;
		}
		else if(joy2Btn(2) == 1)
		{
			servo2angle = 50;
		}
		else
		{
			servo2angle = 126;
		}
		*/

//removed threshold already implemented in joymotor()

	//writeDebugStream("Right: %i | ", SpeedRight);
	//writeDebugStream("Left: %i", SpeedLeft);
	//writeDebugStreamLine("")/;

	//writeDebugStreamLine("%i", Motors_GetPosition(S1, 3, 1));
		writeDebugStreamLine("%i", servo2angle);
	Servos_SetPosition(S1, 2, 1, servoangle);
	Servos_SetPosition(S1, 2, 2, servo2angle);
	Motors_SetSpeed(S1, 1, 1, -SpeedLeft);
	Motors_SetSpeed(S1, 3, 1, SpeedArm);
	Motors_SetSpeed(S1, 1, 2, SpeedRight);



	}

}
